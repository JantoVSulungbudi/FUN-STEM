<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Hand Movement + Pick-up/Open (Wrist zones)</title>

  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>

  <style>
    body {
      background: #111;
      color: #eee;
      font-family: Arial, sans-serif;
      text-align: center;
      margin: 0;
      padding: 12px;
    }
    canvas {
      border: 1px solid #444;
      width: 640px;
      height: 480px;
      display: block;
      margin: 0 auto;
    }
    #status {
      margin-top: 10px;
      font-size: 24px;
      background:#222;
      display:inline-block;
      padding:8px 12px;
      border-radius:6px;
      border:1px solid #333;
    }
    #landmarkBox {
      width: 640px;
      margin: 10px auto;
      background:#000;
      border:1px solid #333;
      color:#ccc;
      padding:8px;
      text-align:left;
      font-family: monospace;
      height:160px;
      overflow:auto;
    }
  </style>
</head>
<body>
  <h2>Hand Movement + PICK-UP / OPEN HAND</h2>

  <video id="video" autoplay playsinline style="display:none"></video>
  <canvas id="canvas" width="640" height="480"></canvas>

  <div id="status">STOP</div>
  <div id="landmarkBox">Waiting for landmarks...</div>

<script>
const video = document.getElementById('video');
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');
const status = document.getElementById('status');
const landmarkBox = document.getElementById('landmarkBox');

let lastOutput = 'NONE';

// small X draw (like your original)
function drawCross(ctx, x, y, size, color) {
  ctx.strokeStyle = color;
  ctx.lineWidth = 2;
  ctx.beginPath();
  ctx.moveTo(x - size, y - size);
  ctx.lineTo(x + size, y + size);
  ctx.moveTo(x + size, y - size);
  ctx.lineTo(x - size, y + size);
  ctx.stroke();
}

// init camera
async function initCamera() {
  const s = await navigator.mediaDevices.getUserMedia({ video: true });
  video.srcObject = s;
}
initCamera();

// ---------- helper distance ----------
function dist2(a, b) {
  const dx = a.x - b.x;
  const dy = a.y - b.y;
  return Math.sqrt(dx*dx + dy*dy);
}

// ---------- Hand state (PICK-UP / OPEN) using landmarks 4,8,12 ----------
function getHandState(landmarks) {
  // ensure indices present
  if (!landmarks || landmarks.length < 13) return null;

  const p4  = landmarks[4];
  const p8  = landmarks[8];
  const p12 = landmarks[12];

  const d48  = dist2(p4, p8);
  const d412 = dist2(p4, p12);
  const d812 = dist2(p8, p12);

  const avg = (d48 + d412 + d812) / 3;

  // thresholds tuned for typical MediaPipe normalized coords
  // PICK-UP when very close (fingers gathered)
  if (avg < 0.06) return 'PICK-UP';

  // OPEN when clearly spread
  if (avg > 0.09) return 'OPEN HAND';

  // otherwise no clear hand state
  return null;
}

// ---------- Movement zones based on wrist only (user's swapped mapping & thresholds) ----------
function getMovement(landmarks) {
  const wrist = landmarks[0];
  if (!wrist) return 'STOP';

  const x = wrist.x; // normalized 0..1 screen
  const y = wrist.y;

  // user requested thresholds:
  const left = 0.4;
  const right = 0.6;
  const top = 0.5;
  const bottom = 0.7;

  // User earlier swapped LEFT and RIGHT:
  // x > right => LEFT
  // x < left  => RIGHT
  if (y < top) return 'UP';
  if (y > bottom) return 'DOWN';
  if (x > right) return 'LEFT';
  if (x < left) return 'RIGHT';
  return 'STOP';
}

// ---------- Results handler ----------
function onResults(results) {
  // draw camera frame
  ctx.save();
  ctx.clearRect(0,0,canvas.width,canvas.height);
  ctx.drawImage(results.image, 0, 0, canvas.width, canvas.height);

  if (!results.multiHandLandmarks || results.multiHandLandmarks.length === 0) {
    // optionally show STOP when hand lost (only if changed)
    const combined = 'STOP';
    if (combined !== lastOutput) {
      status.textContent = combined;
      lastOutput = combined;
    }
    landmarkBox.textContent = 'No hands detected';
    ctx.restore();
    return;
  }

  const landmarks = results.multiHandLandmarks[0];

  // draw skeleton (connectors)
  drawConnectors(ctx, landmarks, HAND_CONNECTIONS, { color: '#00FFAA', lineWidth: 2 });

  // draw all landmarks as small X's (like first version)
  for (let i = 0; i < landmarks.length; i++) {
    const p = landmarks[i];
    drawCross(ctx, p.x * canvas.width, p.y * canvas.height, 3, '#FF4444');
  }

  // compute states
  const handState = getHandState(landmarks); // PICK-UP or OPEN HAND or null
  const moveState = getMovement(landmarks);  // LEFT/RIGHT/UP/DOWN/STOP

  // Combine: if handState exists show as prefix, movement always computed
  // Example outputs: "PICK-UP + LEFT", "OPEN HAND + STOP", "RIGHT"
  let combined = '';
  if (handState) {
    // include movement unless it's STOP and you prefer to show only PICK-UP/OPEN; here we include both
    if (moveState && moveState !== 'STOP') combined = handState + ' + ' + moveState;
    else combined = handState + ' + STOP';
  } else {
    combined = moveState || 'STOP';
  }

  // Only update display when changed
  if (combined !== lastOutput) {
    status.textContent = combined;
    lastOutput = combined;
  }

  // show landmark numeric list (x,y)
  let txt = '';
  for (let i = 0; i < landmarks.length; i++) {
    const p = landmarks[i];
    txt += `\n${i}\t: \tx=${p.x.toFixed(3)}, \ty=${p.y.toFixed(3)}\n`;
  }
  landmarkBox.textContent = txt;

  ctx.restore();
}

// ---------- Mediapipe setup ----------
const hands = new Hands({
  locateFile: file => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`
});
hands.setOptions({
  maxNumHands: 1,
  modelComplexity: 1,
  minDetectionConfidence: 0.6,
  minTrackingConfidence: 0.6
});
hands.onResults(onResults);

const camera = new Camera(video, {
  onFrame: async () => {
    await hands.send({ image: video });
  },
  width: 640,
  height: 480
});
camera.start();
</script>
</body>
</html>
