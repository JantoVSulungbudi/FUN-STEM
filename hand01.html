<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Hand Tracking with Landmark Display</title>

  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>

  <style>
    body {
      background: #111;
      color: white;
      text-align: center;
      font-family: Arial;
    }
    #output_canvas {
      width: 480px;
      height: 360px;
      border: 1px solid #444;
    }
    #landmarkBox {
      width: 480px;
      height: 200px;
      overflow-y: scroll;
      background: #000;
      border: 1px solid #444;
      padding: 10px;
      margin: 10px auto;
      text-align: left;
      font-size: 13px;
      white-space: pre;
    }
  </style>
</head>

<body>
  <h2>Hand Tracking with Cross Markers + Landmark Values</h2>

  <video id="video" autoplay playsinline style="display:none;"></video>
  <canvas id="output_canvas"></canvas>

  <div id="landmarkBox">Waiting for landmarks...</div>

<script>
const video = document.getElementById("video");
const canvas = document.getElementById("output_canvas");
const ctx = canvas.getContext("2d");
const landmarkBox = document.getElementById("landmarkBox");

// ---------------- SMALL "X" DRAW FUNCTION ----------------
function drawCross(ctx, x, y, size, color) {
  ctx.strokeStyle = color;
  ctx.lineWidth = 2;
  ctx.beginPath();
  ctx.moveTo(x - size, y - size);
  ctx.lineTo(x + size, y + size);
  ctx.moveTo(x + size, y - size);
  ctx.lineTo(x - size, y + size);
  ctx.stroke();
}

// ---------------- CAMERA INIT ----------------
async function initCamera() {
  const stream = await navigator.mediaDevices.getUserMedia({ video: true });
  video.srcObject = stream;
}
initCamera();

// ---------------- HAND PROCESSING ----------------
function onResults(results) {
  ctx.save();
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  ctx.drawImage(results.image, 0, 0, canvas.width, canvas.height);

  if (results.multiHandLandmarks) {
    for (const landmarks of results.multiHandLandmarks) {

      // Draw connections
      drawConnectors(ctx, landmarks, HAND_CONNECTIONS, { color: "#00FFAA", lineWidth: 2 });

      // Draw each point as small "X"
      landmarks.forEach((p) => {
        const x = p.x * canvas.width;
        const y = p.y * canvas.height;
        drawCross(ctx, x, y, 1, "#FF4444");
      });

      // Display all landmark values
      const landmarkNames = [
        "Wrist",
        "Thumb CMC", "Thumb MCP", "Thumb IP", "Thumb Tip",
        "Index MCP", "Index PIP", "Index DIP", "Index Tip",
        "Middle MCP", "Middle PIP", "Middle DIP", "Middle Tip",
        "Ring MCP", "Ring PIP", "Ring DIP", "Ring Tip",
        "Pinky MCP", "Pinky PIP", "Pinky DIP", "Pinky Tip"
      ];

      let text = "";
      for (let i = 0; i < landmarks.length; i++) {
        const p = landmarks[i];
        text += `${i} (${landmarkNames[i]}): x=${p.x.toFixed(3)}, y=${p.y.toFixed(3)}, z=${p.z.toFixed(3)}\n`;
      }
      landmarkBox.textContent = text;
    }
  }
  ctx.restore();
}

const hands = new Hands({
  locateFile: file => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`
});
hands.setOptions({
  maxNumHands: 1,
  modelComplexity: 1,
  minDetectionConfidence: 0.6,
  minTrackingConfidence: 0.6
});
hands.onResults(onResults);

// Start camera
const camera = new Camera(video, {
  onFrame: async () => {
    await hands.send({ image: video });
  },
  width: 480, height: 360
});
camera.start();

</script>
</body>
</html>
